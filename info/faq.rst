Q: Why don't we take tests on the computer?

A: There are a few good reasons, but the best of these is pedagogical.  
   With access to a compiler and enough time, many students can arrive at the
   correct solutions through trial-and-error. This doesn't mean the material is
   well-understood.  Paper is committal; it forces the programmer to evaluate
   the correctness of the approach. If you can write it on paper, you really
   know it well.  The foreknowledge that one has to pass a paper test gives
   incentive to study; the opposite is true for a computer test ("I don't have
   to know it that well because the compiler will reveal all my errors during
   the test").  


Q: What is the purpose of the crayon/colored pencil exercises?

A: One purpose is intellectual exercise, 
   which is something everyone needs for higher-level courses. In that regard,
   the point is to have the student work through the logic of a problem while
   holding steps in working memory.  This expands one's capability to do so
   when coding in front of a computer.  That in turn improves design and
   accuracy, which in turn reduces the time spent re-writing the code or
   debugging it. 

   Another is to enforce good software engineering practice: think before
   coding rather than after. Instead of trying all combinations of what one
   guesses might work, logically reason out what is sure to work.  Compare
   the following approaches to problem-solving: (A) Guess the next step
   until the solution is stumbled on, repeating infinitely or until
   convergence; (B) logically reason out the solution along with the
   assurance that it is correct the first time. (B) is better, and is
   what I aim to teach: logical thought in the place of guesswork.


Q: Why no, half, or full credit?

A: A moment of caution saves hours of debugging time.  
   A student benefits more from the experience of receiving half-credit.  Upon
   receiving half-credit for a missing semicolon, one is much less likely to
   miss semicolons in the future. My hope is that the sense of caution this
   inspires will extend to other coursework, such as in mathematics, or in
   other situations requiring thought about a procedure. 

   Another is objectivity; with rules as clear-cut as these, it is hard to
   evaluate a student on anything but the correctness of the solution.  Yet
   another is grading efficiency, so that you can receive feedback faster.


Q: Why don't you cover C++ concept X (or use <array>, etc.)?

A: To focus on algorithmics; the programming language is a vehicle 
   for learning about data structures and algorithms. To put it succinctly, I
   teach programming with C++ rather than C++ with programming.  Programming,
   as all students of computer science come to find, is the logical thought
   process of generating an unambiguous procedure to solve a problem. The
   particulars of the language are secondary to this process.

   I try to teach the language in such a way that the coding is similar to
   that of other languages. Instead of delving far into the specifics of the
   C++ language, to my mind it is better to teach the parts of C++ which are
   common to C, C#, Java, PHP, and other languages that bear similarities.
   This way if my students want to learn another language, they will already
   have a foundation in it.  Those wanting to specialize in C++ particulars
   would be prepared to do so.
